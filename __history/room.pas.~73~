unit room;

interface

uses System.Generics.Collections,FMX.Dialogs,system.JSON;

type roomPlayer = class
  name : string;
  cardsCOunt : integer;
end;

type RmInfo = class

  roomId : string;

  playerLeftMap : TDictionary<string,roomPlayer>;

  playerRightMap :  TDictionary<string,roomPlayer>;

  cardsClickCountMap : TDictionary<string,boolean>;

  holeCards : Tarray<string>;

  MyCards: Tarray<string>;

  choiceCards :TDictionary<string,boolean>;

  outOfCards : Tarray<string>;


  constructor Create;
  destructor Destory;

  public
  procedure SetOrUpdatePlayerMap(uid ,name:string ;TJCards:TJsonArray);
  procedure SetHoleCards(roomId :string;HCards : TJsonArray);
  procedure SetCardsClickCountMap(cards : Tarray<string>);
  procedure AddOrRemoveChoiceCardsMap(card : string ; addOrRemove : boolean);
  procedure HideChoiceCards(cards : Tarray<string>);
  procedure SetOutOfCards(cards : TJsonArray);
  procedure SetLeftAndRigthPlayer(ids : TJsonArray);


end;

var RM :RmInfo;

implementation

uses game,common,user,card;

constructor RmInfo.Create;
begin
    playerLeftMap :=  TDictionary<string,roomPlayer>.Create;
    playerRightMap := TDictionary<string , roomPlayer>.Create;
    cardsClickCountMap := TDictionary<string,boolean>.Create;
    choiceCards := TDictionary<string,boolean>.Create;
end;

destructor RmInfo.Destory;
begin
   playerLeftMap.DisposeOf;
   playerRightMap.DisposeOf;
   cardsClickCountMap.DisposeOf;
   choiceCards.DisposeOf;
   inherited;
end;

procedure RmInfo.SetHoleCards(roomId : string;HCards :TJsonArray);
begin
   rm.roomId := roomId;
   rm.holeCards :=  CM.TJosnArray2TArray(HCards);
   GameInterface.showHoleCards(rm.holeCards);
end;

procedure RmInfo.SetCardsClickCountMap(cards : Tarray<string>);
var i : integer;
begin
    for i := 0 to High(cards) do
    begin
        cardsClickCountMap.AddOrSetValue(cards[i],true);
    end;
    ChoiceCards.Clear;

end;


procedure RmInfo.SetOrUpdatePlayerMap(uid ,name :string ; TJCards :TJsonArray);
var
  cards : Tarray<string>;
begin
   cards:=Cm.TJosnArray2TArray(TJCards);

   if (UI.GetUserId() = uid )then
   begin
      MyCards:= cards;
      GameInterface.showMyCards(MyCards);
      exit;
   end;

   if playerLeftMap.ContainsKey(uid) then
   begin
      playerLeftMap[uid].cardsCOunt:=length(cards);
      if (playerLeftMap[uid].name='')and (name<>'') then
      begin
         playerLeftMap[uid].name := name;
      end;
      GameInterface.ShowLeftPlayerCards(length(cards),name);
      exit;
   end;

   if playerRightMap.ContainsKey(uid) then
   begin
      playerRightMap[uid].cardsCOunt:=length(cards);
      if playerRightMap[uid].name=''and (name<>'') then
      begin
         playerRightMap[uid].name := name;
      end;
     GameInterface.ShowRightPlayerCards(length(cards),name);
     exit;
   end;

end;

procedure RmInfo.SetLeftAndRigthPlayer(ids : TJsonArray);
var
  i  : integer;
  rp : roomPlayer;
begin
   if (playerLeftMap.Count=0)or (PlayerRightMap.Count=0) then
   begin
        rp := roomPlayer.Create();
       for I := 0 to ids.Count-1 do
       begin
           if ui.GetUserId = (ids.Items[i] as TjsonString).Value then
            begin
                 if i=0 then
                 begin
                 playerRightMap.AddOrSetValue((ids.Items[i+1] as TJsonString).Value,rp);
                 PlayerLeftMap.AddOrSetValue((ids.Items[i+2] as TJsonString).Value,rp);
                 exit;
                 end;
                 if i=1 then
                 begin
                 playerRightMap.AddOrSetValue((ids.Items[i+1] as TJsonString).Value,rp);
                 PlayerLeftMap.AddOrSetValue((ids.Items[i-1] as TJsonString).Value,rp);
                 exit;
                 end;
                 if i=2 then
                 begin
                 playerRightMap.AddOrSetValue((ids.Items[i-2] as TJsonString).Value,rp);
                 PlayerLeftMap.AddOrSetValue((ids.Items[i-1] as TJsonString).Value,rp);
                 exit;
                 end;
            end;

       end;

   end;

end;

procedure RmInfo.AddOrRemoveChoiceCardsMap(card :string ; addOrRemove : boolean);
begin
  if addOrRemove then
  begin
    ChoiceCards.TryAdd(card,true);
  end
  else
  begin
    if choiceCards.ContainsKey(card) then
    begin
         choiceCards.Remove(card);
    end;
  end;
end;

procedure RmInfo.HideChoiceCards(cards : Tarray<string>);
var
  i : integer;
begin
  for i := 0 to High(cards) do
  begin
     CI.cardMap[cards[i]].Visible := false;
  end;

end;

procedure RmInfo.SetOutOfCards(cards : TJsonArray);
begin

    if (Length(outofCards)<>0) then
     begin
       HideChoiceCards(outOfcards);
     end;

    outOfCards:=CM.TJosnArray2TArray(cards);
    GameInterface.ShowOutOfCards(outOfCards);
end;

end.
