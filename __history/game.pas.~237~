unit game;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs, FMX.Memo.Types,
  FMX.ScrollBox, FMX.Memo, FMX.Controls.Presentation, FMX.StdCtrls, System.JSON,
  IdBaseComponent, IdComponent, IdTCPConnection, IdTCPClient, FMX.Edit,uDSimpleTcpClient,
  System.ImageList, FMX.ImgList, FMX.Objects,tcp,login,handler,user,setUserName,card,
  common,room, FMX.Layouts, FMX.TreeView,uToast;

type
  TGameInterface = class(TForm)
    StartGame: TButton;
    outOfCard: TButton;
    giveUpCard: TButton;
    cancelMatch: TButton;
    AniIndicator1: TAniIndicator;
    waitting: TText;

    dawang: TImage;
    xiaowang: TImage;

    three_1: TImage;
    three_2: TImage;
    three_4: TImage;
    three_3: TImage;

    four_1: TImage;
    four_2: TImage;
    four_3: TImage;
    four_4: TImage;

    five_1: TImage;
    five_2: TImage;
    five_3: TImage;
    five_4: TImage;

    six_1: TImage;
    six_2: TImage;
    six_3: TImage;
    six_4: TImage;

    seven_1: TImage;
    seven_2: TImage;
    seven_3: TImage;
    seven_4: TImage;

    eight_1: TImage;
    eight_2: TImage;
    eight_3: TImage;
    eight_4: TImage;

    nine_1: TImage;
    nine_2: TImage;
    nine_3: TImage;
    nine_4: TImage;

    ten_1: TImage;
    ten_2: TImage;
    ten_3: TImage;
    ten_4: TImage;

    J_1: TImage;
    J_2: TImage;
    J_3: TImage;
    J_4: TImage;

    Q_1: TImage;
    Q_2: TImage;
    Q_3: TImage;
    Q_4: TImage;

    K_1: TImage;
    K_2: TImage;
    K_3: TImage;
    K_4: TImage;

    A_1: TImage;
    A_2: TImage;
    A_3: TImage;
    A_4: TImage;

    two_1: TImage;
    two_2: TImage;
    two_3: TImage;
    two_4: TImage;
    StyleBook1: TStyleBook;
    background: TImage;
    Layout1: TLayout;
    Image1: TImage;
    leftPlayerCardCount: TText;
    rightPlayerCardCount: TText;
    leftPlayerName: TText;
    rightPlayerName: TText;
    myName: TText;
    rightName: TRectangle;
    leftName: TRectangle;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure StartGameClick(Sender: TObject);
    procedure cancelMatchClick(Sender: TObject);
    procedure showHoleCards(cards : Tarray<string>);
    procedure showMyCards(cards : Tarray<string>);
    procedure FormResize(Sender: TObject);
    procedure ClickCard(Sender: TObject);
    procedure EvaluationImageTagString();
    procedure SetButton();
    procedure SetCards();
    procedure outOfCardClick(Sender: TObject);
    procedure ShowOutOfCards(cards : Tarray<string>);
    procedure ShowLeftPlayerCards(count : integer; name :string);
    procedure ShowRightPlayerCards(count : integer; name : string);

  private
    { Private declarations }
//     image1ClickCount:integer;
  private
//    procedure OnSocketRead(AStream: TMemoryStream);
  public
    { Public declarations }
  end;

var
  GameInterface: TGameInterface;
  LFrame: TLoginFrame;
  SName:TsetUserNameFrame;


implementation

{$R *.fmx}

procedure TGameInterface.FormCreate(Sender: TObject);
begin
    G_TcpMessage := TcpMessage.Create;
    ExHandler := executeHandler.Create;
    UI := UserInfo.Create;
    CM:=cmFunction.Create;
    CI:=CardInfo.Create;

    G_TcpMessage.ConnectionService();


    EvaluationImageTagString();
    SetButton();

    LFrame := TLoginFrame.Create(Self);
    LFrame.Parent := Self;

    SName:=TsetUserNameFrame.Create(Self);
    SName.Parent:=Self;

    SName.BringToFront;
    LFrame.BringToFront;
end;

procedure TGameInterface.FormDestroy(Sender: TObject);
begin
    G_TcpMessage.DisposeOf;
end;

procedure TGameInterface.FormResize(Sender: TObject);
begin
    SetButton();
    SetCards();
end;

procedure TGameInterface.outOfCardClick(Sender: TObject);
var
  card  : string;
  js : TJsonObject;
  JsAy : TjsonArray;
begin
      if rm.choiceCards.Count=0 then
      begin
      Self.LAYOUT1.BringToFront;
      TToast.MakeText(Self.LAYOUT1, '请选择需要出的牌', TToastLength.Toast_LENGTH_LONG);
      exit;
      end;

      js := TJsonObject.Create;
      JsAy := TjsonArray.Create;
      for card in rm.choiceCards.Keys do
      begin
         JsAy.AddElement(TJsonString.Create(card));
      end;

     js.AddPair('cards',JsAy);
     js.AddPair('roomId',TJsonString.Create(rm.roomid));
     G_TcpMessage.SendTcpMessageToService(js.ToString,2007);

     js.DisposeOf;
end;

procedure TGameInterface.SetCards();
  var
  uid : string;
  rp : roomPlayer;
begin
    if ui=nil then
    begin
      exit;
    end;

    uid := ui.GetUserId();
    if (uid = '') or (rm = nil) then
    begin
      exit;
    end;
      if length(rm.MyCards)<>0 then
       begin
          showMyCards(rm.MyCards);
       end;
      if length(rm.outOfCards)<>0 then
      begin
          ShowOutOfCards(rm.outOfCards);
      end;
      if length(rm.holeCards)<>0 then
      begin
          showHoleCards(rm.holeCards);
      end;
      if rm.playerRightMap.Count<>0 then
      begin
          for rp in rm.playerLeftMap.Values do
                begin
                  ShowLeftPlayerCards(rp.cardsCOunt,rp.name);
                end;
      end;
      if rm.playerRightMap.Count<>0 then
      begin
        for rp in rm.playerRightMap.Values do
          begin
            ShowRightPlayerCards(rp.cardsCOunt,rp.name);
          end;
      end;

end;

procedure TGameInterface.StartGameClick(Sender: TObject);
//var
//  js:TJsonObject;
begin
//     js:=TJsonObject.Create;
       G_TcpMessage.SendTcpMessageToService('',2003);
       self.Invalidate;
       AniIndicator1.Visible:=true;
       AniIndicator1.Enabled:=true;
       waitting.Visible:=true;
       startGame.Visible:=false;
       cancelMatch.Visible := true;
end;

procedure TGameInterface.ClickCard(Sender: TObject);
begin
      if rm.cardsClickCountMap[TImage(Sender).TagString] then
      begin
         TImage(Sender).Position.Y:=TImage(Sender).Position.Y - 40;
         rm.cardsClickCountMap[TImage(Sender).TagString] := false;
         rm.AddOrRemoveChoiceCardsMap(TImage(sender).TagString,true)
      end
      else
      begin
        TImage(Sender).Position.Y := TImage(Sender).Position.Y + 40;
        rm.cardsClickCountMap[TImage(Sender).TagString] := true;
        rm.AddOrRemoveChoiceCardsMap(TImage(sender).TagString,false)
      end;
end;

procedure TGameInterface.cancelMatchClick(Sender: TObject);
begin
     G_TcpMessage.SendTcpMessageToService('',2008);
     self.Invalidate;
     AniIndicator1.Enabled:=false;
     AniIndicator1.Visible:=false;
     waitting.Visible:=false;
end;

procedure TGameInterface.ShowOutOfCards(cards : Tarray<string>);
var
 i : integer;
 cardslength : single;
 totalCardsLength : single;
 marginLeft : single;
 marginTop : single;
begin
  if length(cards)=0 then
  begin
    exit;
  end;

    totalCardsLength :=(Length(cards)-1)* 30 + 80;

    marginLeft := (self.Width-totalCardsLength) / 2;

    marginTop := (self.Height-150)/2;

  for i := 0 to High(cards) do
      begin
         CI.cardMap[cards[i]].Position.X := marginleft + i * 30;
         CI.cardMap[cards[i]].Position.Y :=marginTop-80;
         CI.cardMap[cards[i]].Width := 80;
         CI.cardMap[cards[i]].Height := 150;
         CI.cardMap[cards[i]].WrapMode:=TImageWrapMode.Stretch;
         Ci.cardMap[cards[i]].Visible := true;
         CI.cardMap[cards[i]].BringToFront;
      end;

end;


procedure  TGameInterface.showHoleCards(cards : Tarray<string>) ;
var
 i : integer;
 cardslength : single;
 totalCardsLength : single;
 marginLeft : single;
begin
  if length(cards)=0 then
  begin
    exit;
  end;

    totalCardsLength :=(Length(cards)-1)* 50 + 80;

    marginLeft := (self.Width-totalCardsLength) / 2;

  for i := 0 to High(cards) do
      begin
         CI.cardMap[cards[i]].Position.X := marginleft + i * 50;
         CI.cardMap[cards[i]].Position.Y := 0;
         CI.cardMap[cards[i]].Width := 50;
         CI.cardMap[cards[i]].Height := 120;
         CI.cardMap[cards[i]].WrapMode:=TImageWrapMode.Stretch;
         Ci.cardMap[cards[i]].Visible := true;
         CI.cardMap[cards[i]].BringToFront;
      end;
//
end;

procedure TGameInterface.showMyCards(cards : Tarray<string>);
var
 i : integer;
 cardslength : single;
 totalCardsLength : single;
 marginLeft : single;
begin
  if length(cards)=0 then
  begin
    exit;
  end;

    totalCardsLength :=(Length(cards)-1)* 30 + 80;

    marginLeft := (self.Width-totalCardsLength) / 2;

  for i := 0 to High(cards) do
      begin
         CI.cardMap[cards[i]].Position.X := marginleft + i * 30;
         CI.cardMap[cards[i]].Position.Y := self.Height-200;
         CI.cardMap[cards[i]].Width := 80;
         CI.cardMap[cards[i]].Height := 150;
         CI.cardMap[cards[i]].WrapMode:=TImageWrapMode.Stretch;
         Ci.cardMap[cards[i]].Visible := true;
         CI.cardMap[cards[i]].BringToFront;
      end;
      rm.SetCardsClickCountMap(cards);
end;

procedure TGameInterface.ShowLeftPlayerCards(count : Integer; name :string);
//var
// i : integer;
// totalCardsLength : single;
// margin : single;
begin

//    totalCardsLength:=count* 5 + 60;
//     margin:=(self.Width-totalCardsLength)/2;

    cI.backCardArray[0].Position.X:=25;
    CI.backCardArray[0].Position.Y := self.Height/2-CI.backCardArray[0].Height;
    CI.backCardArray[0].WrapMode:= TimageWrapMode.Stretch;
    CI.backCardArray[0].Visible := true;
    CI.backCardArray[0].BringToFront;

    leftPlayerCardCount.Position.X := 25+15;
    leftPlayerCardCount.Position.Y := self.Height/2;
    leftPlayerCardCount.Size.Height:=30;
    leftPlayerCardCount.Size.Width:=30;
    leftPlayerCardCount.Text := count.ToString;
    leftPlayerCardCount.Visible := true;
    leftPlayerCardCount.BringToFront;

//    leftPlayerName.Width:=30;
//    leftPlayerName.Height:=10;
//    leftPlayerName.Position.X:=15;
//    leftPlayerName.Position.Y:=self.Height/2-100-20;
//    leftPlayerName.Text := name;
//    leftPlayerName.Visible := true;
//    leftPlayerName.BringToFront;
//   for I := 0 to (count-1) do
//      begin
//        CI.backCardArray[i].Position.X := 25 + i*5;
//        CI.backCardArray[i].Position.Y := self.Height/2-CI.backCardArray[i].Height;
//        CI.backCardArray[i].WrapMode:= TimageWrapMode.Stretch;
//        CI.backCardArray[i].Visible := true;
//        CI.backCardArray[i].BringToFront;
//      end;

end;

procedure TGameInterface.ShowRightPlayerCards(count : Integer;name :string);
//var
// i : integer;
// totalCardsLength : single;
// margin : single;
begin


    cI.backCardArray[1].Position.X:=self.Width-100;
    CI.backCardArray[1].Position.Y := self.Height/2-CI.backCardArray[1].Height;
    CI.backCardArray[1].WrapMode:= TimageWrapMode.Stretch;
    CI.backCardArray[1].Visible := true;
    CI.backCardArray[1].BringToFront;

    rightPlayerCardCount.Position.X := self.Width-100+15;
    rightPlayerCardCount.Position.Y := self.Height/2;
    rightPlayerCardCount.Size.Height:=30;
    rightPlayerCardCount.Size.Width:=30;
    rightPlayerCardCount.Text := count.ToString;
    rightPlayerCardCount.Visible := true;
    rightPlayerCardCount.BringToFront;

    rightName.Position.X:=self.Width-100-50;
    rightName.Position.Y:=self.Height/2-CI.backCardArray[1].Height-50;
//    rightName.Fill.Kind:= TBrushKind.None;
    rightPlayerName.Text := name;
    rightPlayerName.Visible := true;
    rightName.Visible:=true;
    rightName.BringToFront;

//    totalCardsLength:=count* 5 + 60;
//     margin:=(self.Width-totalCardsLength)/2;
//  for I := 0 to count do
//    begin
//        CI.backCardArray[i+20].Position.X:=(self.Width-100) - i*5;
//        CI.backCardArray[i+20].Position.Y:= self.Height/2-CI.backCardArray[i].Height;
//        CI.backCardArray[i+20].WrapMode:=TimageWrapMode.Stretch;
//        CI.backCardArray[i+20].Visible:=true;
//        CI.backCardArray[i+20].BringToFront;
//    end;
end;

procedure TGameInterface.SetButton();
begin
  //
  StartGame.Position.X:=(self.Width-StartGame.Width)/2;
  StartGame.Position.Y:=self.Height-230;

  cancelMatch.Position.X:=(self.Width-cancelMatch.Width)/2;
  cancelMatch.Position.Y:=self.Height-230;

  waitting.Position.X:=(self.Width-waitting.Width)/2+7;
  waitting.Position.Y:=self.Height-265;

  AniIndicator1.Position.X:=(self.Width-AniIndicator1.Width)/2-7;
  AniIndicator1.Position.Y:=self.Height-325;

  giveUpCard.Position.X:=(self.Width-giveUpCard.Width)/2 -100;
  giveUpCard.Position.Y:=self.Height-275;

  outOfCard.Position.X:=(self.Width-outOfCard.Width)/2 + 100;
  outOfCard.Position.Y:=self.Height-275;

end;

procedure TGameInterface.EvaluationImageTagString();
begin
    dawang.TagString:= 'Q88';
    xiaowang.TagString:= 'K99';

    three_1.TagString:= 'A3';
    three_2.TagString:= 'B3';
    three_3.TagString:= 'C3';
    three_4.TagString:= 'D3';


    four_1.TagString:= 'A4';
    four_2.TagString:= 'B4';
    four_3.TagString:= 'C4';
    four_4.TagString:= 'D4';

    five_1.TagString:= 'A5';
    five_2.TagString:= 'B5';
    five_3.TagString:= 'C5';
    five_4.TagString:= 'D5';

    six_1.TagString:= 'A6';
    six_2.TagString:= 'B6';
    six_3.TagString:= 'C6';
    six_4.TagString:= 'D6';

    seven_1.TagString:= 'A7';
    seven_2.TagString:= 'B7';
    seven_3.TagString:= 'C7';
    seven_4.TagString:= 'D7';

    eight_1.TagString:= 'A8';
    eight_2.TagString:= 'B8';
    eight_3.TagString:= 'C8';
    eight_4.TagString:= 'D8';

    nine_1.TagString:='A9';
    nine_2.TagString:='B9';
    nine_3.TagString:='C9';
    nine_4.TagString:='D9';

    ten_1.TagString:='A10';
    ten_2.TagString:='B10';
    ten_3.TagString:='C10';
    ten_4.TagString:='D10';

    J_1.TagString:='A11';
    J_2.TagString:='B11';
    J_3.TagString:='C11';
    J_4.TagString:='D11';

    Q_1.TagString:='A12';
    Q_2.TagString:='B12';
    Q_3.TagString:='C12';
    Q_4.TagString:='D12';

    K_1.TagString:='A13';
    K_2.TagString:='B13';
    K_3.TagString:='C13';
    K_4.TagString:='D13';

    A_1.TagString:='A14';
    A_2.TagString:='B14';
    A_3.TagString:='C14';
    A_4.TagString:='D14';

    two_1.TagString:= 'A15';
    two_2.TagString:= 'B15';
    two_3.TagString:= 'C15';
    two_4.TagString:= 'D15';
end;

end.

